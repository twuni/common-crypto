package org.twuni.common.crypto.rsa;

import static java.math.BigInteger.ONE;

import java.math.BigInteger;

import org.twuni.common.crypto.Base64;
import org.twuni.common.crypto.Transformer;

public class PrivateKey implements Transformer<BigInteger, BigInteger> {

	/**
	 * An exponent commonly used in practice due to its being sufficiently large to avoid small
	 * exponent attacks yet small enough to perform encryption efficiently.
	 * 
	 * @see <a href="http://en.wikipedia.org/wiki/65537">65537</a> on Wikipedia
	 */
	public static final BigInteger DEFAULT_EXPONENT = BigInteger.valueOf( 0x10001 );

	private final BigInteger p;
	private final BigInteger q;
	private final BigInteger dP;
	private final BigInteger dQ;
	private final BigInteger inverse;
	private final PublicKey publicKey;

	/**
	 * Convenience constructor which creates an RSA private key with the given prime numbers, using
	 * the default exponent of {@link #DEFAULT_EXPONENT}.
	 * 
	 * @param p
	 *            The greater of the two prime numbers used in the RSA algorithm.
	 * @param q
	 *            The lesser of the two prime numbers used in the RSA algorithm.
	 */
	public PrivateKey( BigInteger p, BigInteger q ) {
		this( p, q, DEFAULT_EXPONENT );
	}

	/**
	 * Constructs an RSA private key with the given criteria.
	 * 
	 * @param p
	 *            The greater of the two prime numbers used in the RSA algorithm.
	 * @param q
	 *            The lesser of the two prime numbers used in the RSA algorithm.
	 * @param exponent
	 *            The exponent used in the RSA algorithm.
	 */
	public PrivateKey( BigInteger p, BigInteger q, BigInteger exponent ) {

		BigInteger d = exponent.modInverse( p.subtract( ONE ).multiply( q.subtract( ONE ) ) );

		this.p = p;
		this.q = q;
		this.publicKey = new PublicKey( p.multiply( q ), exponent );
		this.dP = d.remainder( p.subtract( ONE ) );
		this.dQ = d.remainder( q.subtract( ONE ) );
		this.inverse = q.modInverse( p );

	}

	public PublicKey getPublicKey() {
		return publicKey;
	}

	/**
	 * Transforms the given input using the Chinese-Remainder Theorem.
	 * 
	 * @param input
	 *            A number less than <code>p * q</code> representing either a block of plaintext or
	 *            a block that has been encrypted with this key's corresponding public key.
	 * @see <a href="http://en.wikipedia.org/wiki/Chinese_remainder_theorem">Chinese remainder
	 *      theorem</a> on Wikipedia
	 */
	@Override
	public BigInteger transform( BigInteger input ) {

		BigInteger mP, mQ, h, m;

		mP = ( input.remainder( p ) ).modPow( dP, p );
		mQ = ( input.remainder( q ) ).modPow( dQ, q );

		h = mP.subtract( mQ );
		h = h.multiply( inverse );
		h = h.mod( p );

		m = h.multiply( q );
		m = m.add( mQ );

		return m;

	}

	/**
	 * Serializes the essential fields of this key as a newline-delimited, base64-encoded string.
	 */
	public String serialize() {

		StringBuilder string = new StringBuilder();

		string.append( Base64.encode( p.toByteArray() ) ).append( "|" );
		string.append( Base64.encode( q.toByteArray() ) ).append( "|" );
		string.append( Base64.encode( publicKey.getExponent().toByteArray() ) );

		return string.toString();

	}

	/**
	 * Constructs a new RSA private key using the given serial, generated by calling
	 * {@link #serialize()}.
	 * 
	 * @param serial
	 *            The base64-encoded serialization of the private key, obtained by calling
	 *            {@link #serialize()}.
	 */
	public static PrivateKey deserialize( String serial ) {

		String [] args = serial.split( "\\|" );

		BigInteger p = new BigInteger( Base64.decode( args[0] ) );
		BigInteger q = new BigInteger( Base64.decode( args[1] ) );
		BigInteger exponent = new BigInteger( Base64.decode( args[2] ) );

		return new PrivateKey( p, q, exponent );

	}

	@Override
	public boolean equals( Object object ) {
		if( object instanceof PrivateKey ) {
			PrivateKey key = (PrivateKey) object;
			return p.equals( key.p ) && q.equals( key.q ) && publicKey.equals( key.publicKey );
		}
		return false;
	}

	@Override
	public String toString() {
		return serialize();
	}

}
